# Complete Design Token Rules (T-D-W-P System)

## Core Structure
The token system consists of a single JSON file with two top-level objects:
- `Primitives`: Raw design values
- `MUI`: Semantic tokens that reference primitives

## T-D-W-P: Token Processing Order of Operations
Follow this precise order of operations when processing tokens:

### T: Type Determination
1. Determine the token's `$type` based on Tokens Studio taxonomy
2. Use **exactly** these type values:
   - `color`
   - `fontSize` (not fontSizes)
   - `fontWeights` (not fontWeightss)
   - `fontFamilies` (not fontFamilies)
   - `lineHeight` (not lineHeights)
   - `letterSpacing`
   - `borderRadius`
   - `borderWidth`
   - `spacing`
   - `sizing`
   - `opacity`
   - `boxShadow`
   - `typography`
   - `paragraphSpacing`
   - `textCase`
   - `textDecoration`
   - `composition`
   - `dimension`
   - `breakpoints`
   - `border`
   - `zIndex`
   - `duration`
   - `assets`
   - `boolean`
   - `text`
   - `number`
   - `other` (use only if absolutely necessary)

### D: Decide Category
1. Every token belongs to one of the canonical categories:
   - Color
   - FontSize
   - fontWeights
   - fontFamilies
   - LineHeight
   - LetterSpacing
   - BorderRadius
   - BorderWidth
   - Spacing
   - Sizing
   - Opacity
   - BoxShadow
   - Typography
   - ParagraphSpacing
   - TextCase
   - TextDecoration
   - Composition
   - Dimension
   - Breakpoints
   - Border
   - ZIndex
   - Duration
   - Assets
   - Boolean
   - Text
   - Number
   - Other (use only if absolutely necessary)
2. Categories must use PascalCase singular form (e.g., `FontSize` not `FontSizes`)
3. Do not invent new categories not on this list

### W: Wrapping Decision
Apply this critical test to determine token placement:
1. Convert both the token's `$type` and its category name to lowercase
2. Compare them exactly (case-insensitive comparison):
   - If they match (e.g., `color` = `color`): Place token directly under `Primitives` (no wrapping)
   - If they differ (e.g., `fontsize` â‰  `typography`): Place token under its PascalCase category
3. If a token's category and type match, it MUST be placed directly under `Primitives` without any wrapper

### P: Path and Property Formatting
1. Every token must have exactly these three properties:
   - `$value`: The raw value (must be a string or number for primitives)
   - `$type`: The type determined in step T
   - `$description`: Clear description of the token's purpose
2. Format token names based on placement:
   - For tokens directly under `Primitives`: 
     - Colors: Use lowercase dot notation (e.g., `blue.500`, `red.A100`)
     - Others: Use PascalCase (e.g., `Xl`, `Medium`)
   - For tokens under categories: Always use PascalCase (e.g., `Xl`, `Medium`)

## Primitive vs. Semantic Token Rules
1. Primitives must have direct raw values (string or number)
2. Semantic tokens in `MUI` can reference primitive tokens
3. Reference syntax: `{Primitives.Category.TokenName}` (e.g., `{Primitives.FontSize.Xl}`)
4. For unwrapped primitives: `{Primitives.blue.500}` or `{Primitives.Xl}`
5. Exclude tokens from `Primitives` with these characteristics:
   - Values that are objects, arrays, or references
   - Keys that start with semantic prefixes (e.g., `palette.`, `common.`, `action.`)

## Corrected Examples

### Example 1: Color Token (type = "color" matches category "Color")
```json
"Primitives": {
  "blue.500": {
    "$value": "#2196f3",
    "$type": "color",
    "$description": "blue 500"
  }
}
```

### Example 2: Font Size Token (type = "fontSize" matches category "FontSize")
```json
"Primitives": {
  "Xl": {
    "$value": "24px",
    "$type": "fontSize",
    "$description": "Extra large font size"
  }
}
```

### Example 3: Typography Token (type = "letterSpacing" doesn't match category "Typography")
```json
"Primitives": {
  "Typography": {
    "LetterLg": {
      "$value": "0.1em",
      "$type": "letterSpacing",
      "$description": "Large letter spacing"
    }
  }
}
```

### Example 4: Semantic Token Referencing Primitives
```json
"MUI": {
  "Typography": {
    "Heading": {
      "H1": {
        "$type": "typography",
        "$value": {
          "fontFamilies": "{Primitives.fontFamilies.Primary}",
          "fontSize": "{Primitives.Xl}",
          "fontWeights": "{Primitives.Bold}",
          "lineHeight": "{Primitives.LineHeight.Xl}"
        },
        "$description": "H1 heading style"
      }
    }
  }
}
```

## Special Rule for Color Tokens
- Color tokens ALWAYS use lowercase dot notation (e.g., `blue.500`)
- NEVER wrap color tokens in a "Color" category
- Use consistent color naming patterns (e.g., `blue.500`, `red.A100`)

## Common Errors to Avoid
1. **Double Nesting**: Never create nested groups under `Primitives` (e.g., `Primitives.Typography.FontSize`)
2. **Inconsistent Types**: Never use plural forms in `$type` (e.g., `fontSizes` instead of `fontSize`)
3. **Wrapping Matching Types**: Never wrap tokens when type and category match (e.g., never put `Xl` with type `fontSize` under a `FontSize` category)
4. **Semantic in Primitives**: Never include references or composite values in `Primitives`
5. **Missing Properties**: Always include all three required properties (`$value`, `$type`, `$description`)

## Complete Example Structure
```json
{
  "$schema": "https://design-tokens.github.io/design-tokens/schema.json",
  "Primitives": {
    // Unwrapped tokens (type matches category)
    "blue.500": {
      "$value": "#2196f3",
      "$type": "color",
      "$description": "blue 500"
    },
    "Xl": {
      "$value": "24px",
      "$type": "fontSize",
      "$description": "Extra large font size"
    },
    "Bold": {
      "$value": "700",
      "$type": "fontWeights",
      "$description": "Bold font weight"
    },
    
    // Wrapped tokens (type differs from category)
    "Typography": {
      "LetterLg": {
        "$value": "0.1em",
        "$type": "letterSpacing",
        "$description": "Large letter spacing"
      }
    }
  },
  "MUI": {
    // Semantic tokens structure
    "Typography": {
      "Heading": {
        "H1": {
          "$type": "typography",
          "$value": {
            "fontFamilies": "{Primitives.fontFamilies.Primary}",
            "fontSize": "{Primitives.Xl}",
            "fontWeights": "{Primitives.Bold}",
            "lineHeight": "{Primitives.LineHeightXl}"
          },
          "$description": "H1 heading style"
        }
      }
    }
  }
}
```

## Best Practices
1. **Consistent Naming**: Use consistent naming across categories (e.g., `Xs`, `Sm`, `Md`, `Lg`, `Xl`)
2. **Clear Descriptions**: Write clear, detailed descriptions for every token
3. **Single Source of Truth**: Semantic tokens should reference primitives
4. **Naming Conventions**: Follow PascalCase for categories and token names (except colors)
5. **Valid References**: Check that all references point to existing tokens
6. **JSON Validation**: Ensure JSON is valid before using with Tokens Studio

## Note on "Grouped by Category"
Conceptually grouping tokens by category does not always mean wrapping them in JSON objects. The Wrapping Decision (W step) determines the actual structure. The rule "do not wrap tokens in a category object if the category and type are the same" takes precedence.

Follow these rules in exact order (T-D-W-P) to ensure consistent token structure with no contradictions.