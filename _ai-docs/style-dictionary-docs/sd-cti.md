## Summary of my findings:
- You enable CTI support by including the attribute/cti transform. This enriches each token with a category, type, and item based on its hierarchical path.
- You apply a CTI-based naming transform like name/cti/kebab after that. This ensures token names are generated using their CTI segments, like font-size-xl instead of just xl.
- You define a custom transform group to combine these transforms in the correct order. This transform group must be registered and referenced by name in your platform config.
- With CTI naming active, you avoid collisions between unrelated tokens that happen to share the same leaf key, because their name is now fully scoped and descriptive.

---

Research + Docs

Style Dictionary **does have a solution** for configuring transform group to include CTI (Category/Type/Item) based naming. This is achieved by utilizing specific transforms that make the CTI structure available and apply naming based on it.

Here's how the sources describe this capability:

1.  **Enabling CTI Attributes:** To base naming and filtering on CTI, you first need to make these attributes available on your token objects during the transformation process. This is done by including the `attributes CTI` transform in your transform group. This transform adds an `attributes` object to each token, containing properties like `category`, `type`, and `item`, derived from the token's hierarchical name structure (e.g., `color.base.red` would give `category: color`, `type: base`, `item: red`).
2.  **Applying CTI-Based Naming:** Once the CTI attributes are available, you can use a naming transform that leverages them. Source specifically shows adding the `name/CTI/kebab` transform to a custom transform group. This transform takes the CTI segments (Category, Type, Item) and uses them to generate a name in kebab-case, such as `category-type-item`. For example, a token structure like `color.base.red` could become `color-base-red`. While the source examples show names like `color-base-gray-light` or `size-font-small`, the principle applies to deriving names like `font-size-xl` or `border-radius-xl` if your token structure follows a Category.Type.Item or Category.Item pattern where `font.size.xl` or `border.radius.xl` aligns with CTI. Source also shows using the standard `name/kebab` transform after enabling `attribute CTI`, resulting in kebab-cased names that reflect the token path, aligning with the CTI structure if the path is organized that way.
3.  **Configuration:** This CTI-based naming, along with other desired transforms (like handling units, colors, etc.), is applied by defining a **custom transform group** in your Style Dictionary configuration. You list the specific transforms you want to apply in the desired order within this custom group, ensuring `attributes CTI` is included to make the attributes available for the naming transform. This custom transform group is then specified in the `platforms` section of your configuration. The Style Dictionary configuration can be provided via a `config.json` file or directly as a JavaScript object when using the Node.js API. Using the Node.js API allows for programmatic creation and registration of custom transforms and groups.
4.  **Purpose and Benefits:** The sources demonstrate that having CTI attributes and corresponding names is highly useful, particularly for **filtering** tokens. You can write filters that check `token.attributes.category`, `token.attributes.type`, etc., to selectively include tokens in different output files. This enables advanced use cases like splitting output tokens per component or per category into separate files or directories. This aligns with your goal of scoping and potentially preventing naming collisions by allowing you to organize your output files based on these attributes, where token names within those files are derived predictably from the CTI structure.

In essence, the combination of the `attributes CTI` transform and a CTI-aware naming transform (like `name/CTI/kebab` or `name/kebab` used in conjunction with `attributes CTI`) within a custom transform group provides the mechanism within Style Dictionary to achieve the CTI-based kebab-case naming you described.